<!-- to make pages in the backend, we can add html files in the server and navigate those in the web link 

HTTP response codes- codes indicate whether a specific HTTP request has been successfully completed
Informational responses (100 – 199)
Successful responses (200 – 299)
Redirection messages (300 – 399)
Client error responses (400 – 499)
Server error responses (500 – 599)

nodemon is a tool that helps develop Node.js based applications by automatically restarting the node application when file changes in the directory are detected.
whenever we save the file, regardless of changes being made in it or not, every time the server restarts due to nodemon and the changes are reflected.

npm init command and all the further instructions commands and details are used to create a package json file only for a project, 

to create new folders- mkdir controllers, db, middlewares, models ,routes ,utils 
to create one file-  New-Item -Path "app.js" -ItemType "File"
to create many new files- 
$files= "config.js", "index.js", "server.js"
foreach ($file in $files){
    New-Item -Path $file -ItemType File
}

express- import express is done at the top, exp request is- (req,res,next), app.use/app.get/app.post etc are used for configuring exp routes/middleware
app.use(express.json()); this is a  Middleware
app.get('/users', (req, res) => res.json({ users: [] })); this is a Route
next(); used to cal the next middleware

dotenv and env- dotenv pkg helps to lead environment variables from a .env file into process.env, in env files we store sensitive data like api keys, passwords, etc. so we don't have to hardcode that information into our source code and load it using dotenv, we can also use env files to store 
configuration settings for the app.By default, the dotenv package looks for the .env file in the root directory of your project, not inside the src folder, hence always put the env/env.sample or any ther files related to env in the root directory of the project.

cors-cross origin resource sharing, it is a security mechanism that lets web pages access resources from other domains, meaning it is used to tell who should be able to talk to my database, it is an eg of a middleware

middlewares- intercepts requests, in between configurations, routes, and controllers, we can add middlewares to add some extra functionality to the app, like logging, authentication, etc., used to manipulate if a specific req(say for eg) comes to the server, so should we be accepting that or
anything related to the req, res, next, etc. can be done in the middlewares, like accesisng cookies and headers, etc. in this, next keywrod is used to pass on to the next middleware, if not used, the req will be stuck in the current middleware only, 
prehook and posthook are also used in middlewares, prehook is used to run before the req is sent to the server and posthook is used to run after the req is sent to the server.

models- defines schemas eg-video model, user model, tweet model etc

dbs- always expect errors in this hence always use a trycatch block, holds db config and logic

controller- used to write the logic and handle requests from clients and send responses back, business logic of the app

routes-does the routing of the controller defined things, will group all user endpts in user.routes.js

utils-stores utility functions across application, drafts generic specific response, error or whatever needs to be used, gives an outline to it

appjs- (application configuration)creates express application instance, configures all middlewares routes etc
index.js-(server logic)entry point server,  Imports the app from app.js and calls app.listen() to start the HTTP server
constant.js- holds constant vales throughout the application

multer- middleware for handling file uploads, express.js cannot handle file uploads so we use this to parse the uploaded files from requests,
store those files.

-->